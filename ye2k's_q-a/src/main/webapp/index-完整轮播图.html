<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            list-style: none;
        }

        .box {
            width: 790px;
            height: 340px;
            margin: 100px auto;
            /* overflow: hidden; */
            position: relative;
            transform-style: preserve-3d;
        }

        .box ul {
            width: 100%;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
            transform: rotateX(30deg);
        }

        .box ul li {
            position: absolute;
            left: 0;
            top: 0;
            width: 100px;
            height: 100px;
        }

        /*小圆点*/
        .box ol {
            position: absolute;
            z-index: 99;
            left: 50%;
            transform: translateX(-50%);
            bottom: 20px;
            background-color: rgba(255, 255, 255, .5);
            border-radius: 20px;
            padding: 0 5px;
        }

        .box ol li {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            float: left;
            margin: 5px;
            background-color: #fff;
            cursor: pointer;
        }

        /* .box ol li.active {
            background-color: red;
        } */

        /*左右箭头*/
        .box .arrow {
            display: none;
        }

        .box:hover .arrow {
            display: block;
        }

        .box .arrow span {
            width: 30px;
            height: 60px;
            background-color: rgba(0, 0, 0, .3);
            position: absolute;
            z-index: 99;
            top: 50%;
            transform: translateY(-50%);
            color: #fff;
            font-size: 20px;
            text-align: center;
            line-height: 60px;
            font-family: "宋体";
            cursor: pointer;
        }

        .box .arrow span.left {
            left: 0;
        }

        .box .arrow span.right {
            right: 0;
        }

        .box ul #a {
            background-color: red;
        }

        .box ul #b {
            transform: rotateY(60deg);
            background-color: orange;

        }

        .box ul #c {
            background-color: lime;
            transform: translateX(-790px) rotateY(120deg);

        }

        .box ul #d {
            background-color: skyblue;
            transform: translateX(-790px) rotateY(120deg);

        }

        .box ul #e {
            background-color: violet;
            transform: translateX(-790px) rotateY(120deg);

        }

        .box ul #f {
            background-color: black;
            transform: translateX(-790px) rotateY(120deg);

        }

        .box ul #g {
            background-color: rgb(211, 124, 124);
            transform: rotateX(90deg) translateZ(170px);

        }
    </style>
</head>

<body>
    <!-- 窗口，展示图片，尺寸和一张图片保持一样大小 -->
    <div class="box">
        <!-- 放图片的列表 -->
        <ul>
            <li id="g"><a href="#"></a></li>
            <li id="a"><a href="#"></a></li>
            <li id="b"><a href="#"></a></li>
            <li id="c"><a href="#"></a></li>
            <li id="d"><a href="#"></a></li>
            <li id="e"><a href="#"></a></li>
            <li id="f"><a href="#"></a></li>
        </ul>
        <!-- 小圆点 -->
        <ol></ol>
        <!-- 左右箭头 -->
        <div class="arrow">
            <span class="left">&lt;</span>
            <span class="right">&gt;</span>
        </div>
    </div>
    <script src="./js/turbo-.js"></script>
    <script>
        // 共识：
        //  1. 轮播图动的是ul列表，修改ul的left
        //  2. ul的left取值只能是0或者是负值，不能是正值（否则会出现留白）

        // 找对象
        var box = document.querySelector(".box");
        var ul = box.querySelector("ul");
        var ol = box.querySelector("ol");
        var imgs = ul.children; // li的个数等于img的个数 动态集合
        console.log(imgs);
        var leftBtn = box.querySelector(".arrow .left");
        var rightBtn = box.querySelector(".arrow .right");
        var imgWidth = box.offsetWidth;


        // 需求：
        // 1. js动态添加小圆点
        // 2. js动态添加最后一张假图片
        // 3. 实现左右焦点图 + 无缝滚动
        // 4. 自动播放
        // 5. 点击小圆点同步切换
        // 6. 解决点击小圆点的bug


        // 需求1. js动态添加小圆点
        // 实现思路：需要根据图片的个数来决定创建并添加多少个小圆点
        for (var i = 0; i < imgs.length; i++) {
            // 每循环一次创建一个小圆点li
            var newLi = document.createElement("li");
            // 把创建的li添加到ol中
            ol.appendChild(newLi);
        }
        // points的获取放到for循环后面，确保可以获取到所有的小圆点
        var points = box.querySelectorAll("ol li"); // 静态集合
        // 还需要把第一个小圆点添加active类名
        points[0].className = "active";

        // 注意点： 需求1和需求2的代码位置顺序不能反过来，否则会导致添加的小圆点变成9个。
        // 原因是因为imgs是通过children来获取的（动态集合）

        // 需求2. js动态添加最后一张假图片
        //  把ul的第一个li克隆一份，把克隆的添加到最后面去
        // ul.appendChild(ul.firstElementChild.cloneNode(true));

        // 需求3： 实现左右焦点图 + 无缝滚动
        var count = 0; // ul出去的图片张数，默认ul出去的0张图片

        // 点击右箭头，展示下一张
        //  ==> 只需要让ul出去的图片的张数增加一张

        // 当展示的是最后一张茶叶的时候，点击右箭头，ul不动（不会出现空白）
        //  需要做判断
        rightBtn.onclick = function () {
            if (count >= imgs.length - 1) {
                // 当前展示的是假图片，ul不动
                // return; // 后面代码不执行
                // 假图片 ==> 第二张
                // 1、 先让ul瞬间回到第一张
                ul.style.left = 0;
                count = 0; // 同步count的值,别落下，否则位置不对
            }

            count++;
            animate(ul, -count * imgWidth);
            console.log("ul出去的图片的张数 ", count);

            // 同步小圆点（排他）
            for (var i = 0; i < points.length; i++) {
                points[i].className = "";
            }
            // 复活一个小圆点 // this ==> 右箭头
            //   从points伪数组中根据下标找一个小圆点复活
            //   下标就是当前count的值

            // 判断： 当展示假图片的时候，需要让第一个小圆点高亮
            if (count >= imgs.length - 1) {
                // count >= 8
                // 当前展示假图片的时候
                points[0].className = "active";
            } else {
                // count 0-7
                points[count].className = "active";
            }
        }

        // 点击左箭头，展示上一张
        //   让ul出去的张数减少一张

        // 判断，当展示第一张的时候，点击左箭头，ul不动（留白）

        leftBtn.onclick = function () {
            if (count <= 0) {
                // return; // 应该从第一张展示最后一张茶叶
                // 1. 先让ul瞬间回到假图片的位置
                count = imgs.length - 1; // 同步count的值
                ul.style.left = -count * imgWidth + "px";

                // 2. 在从假图片的位置展示上一次（茶叶）
            }

            count--;
            animate(ul, -count * imgWidth);
            console.log("ul出去的图片的张数 ", count);

            // 同步小圆点（排他）
            for (var i = 0; i < points.length; i++) {
                points[i].className = "";
            }
            if (count >= imgs.length - 1) {
                // count >= 8
                // 当前展示假图片的时候
                points[0].className = "active";
            } else {
                // count 0-7
                points[count].className = "active";
            }
        }


        /*// 需求4. 自动播放
        //  开个定时器 ==> 自动展示下一张 ==> 把右箭头的点击事件处理函数给调用下
        var timerId = setInterval(function() {
            rightBtn.onclick();
        }, 1500)
    
        // 当鼠标移入box上，清除定时器
        box.onmouseover = function() {
            clearInterval(timerId);
        }
    
        // 当鼠标移出box，重新开定时器
        box.onmouseout = function() {
            //  注意点：timerId变量的前面不能加var，否则是局部变量，在onmouseover事件中没有办法来清除这里开启的定时器
            //  timerId变量也不能省略掉
            timerId = setInterval(function() {
                rightBtn.onclick();
            }, 1500)
        }*/

        // 需求5：点击小圆点实现切换
        //  1. ul的位置发生改变
        //  2. 小圆点的排他
        //  3. 同步count的值
        for (var i = 0; i < points.length; i++) {
            // 存下标
            points[i].index = i;

            // 注册click事件
            points[i].onclick = function () {
                // 解决taobao的bug
                //  当展示假图片，点击小圆点，让ul瞬间回到真正的第一张
                if (count >= imgs.length - 1) {
                    // 当展示假图片
                    ul.style.left = 0;
                    count = 0; // 同步count可写可不写，因为下面还会修改count的值。
                }

                // 1. ul的位置发生改变
                animate(ul, -this.index * imgWidth);

                // 2. 小圆点的排他
                for (var i = 0; i < points.length; i++) {
                    points[i].className = "";
                }
                this.className = "active";

                // 3. 同步count的值 ==> 当前点击小圆点的下标
                count = this.index;
            }
        }

    // 需求6. 解决点击小圆点的bug
    //  当展示假图片的时候，点击小圆点，会发现ul是倒退着回到对应的图片
    //  解决bug代码位置：写在小圆点的点击事件处理函数中
    </script>
</body>

</html>