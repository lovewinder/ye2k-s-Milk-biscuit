1[sp]transition: width 1s 3s linear;<br>(1) transition-property: 设置过渡属性<br>(2) transition-duration: 设置过渡时间<br>(3) transition-delay: 设置过渡延时<br>(4) transition-timing-function: 设置过渡的速度(linear/ease/steps(10)等)<br>* 如果过渡属性加给了hover状态,返回时就没有过渡效果了[or]
2[sp](1) transform: translateX(100px)<br>(2) transform: translateY(100px);<br>(3) transform: translate(100px, 100px);<br>(4) transform: translate(50%, 50%);<br>* translate的值可以是px,也可以是百分比,如果是百分比,那么参照的是自身的宽高<br>* translate移动的元素并不会影响其他盒子,类似于相对定位[or]
3[sp](1) transform: scaleX(0.5)<br>(2) transform: scaleY(0.5)<br>(3) transform: scale(0.5)<br>* scale接收的值倍数,没有单位<br>* 可以通过transition-origin设定旋转原点[or]
4[sp](1) transform: rotate(360deg);<br>(2) transform: rotate(-360deg);<br>* 单位是deg,角度,不是px<br>* 正值顺时针转,负值逆时针转<br>* 可以通过transform-origin设定旋转原点[or]
5[sp](1) transform: skewX(30deg);<br>(2) transform: skewY(30deg);[or]
6[sp](1) transform-origin: center center;<br>(2) transform-origin: 40px 40px;[or]
7[sp](1) 当一个元素有多个2D转换(比如: 既旋转又缩放)效果,采用连写的方式<br>(2) 2D转换的顺序不同,结果也就不同,主要针对的是移动和旋转(物体发生了旋转,内部坐标系也跟着发生了旋转)<br>(3) 多个状态下面有2D转换效果时,需要复制前面已经存在的transform效果(转换至)[or]
8[sp]perspective：500px;<br>* 设置了perspective属性后,就有了进大远小的效果了,在视觉上,让我们能看出来3d的效果<br> 当为元素定义perspective属性时,其子元素会获得透视效果,而不是元素本身[or]
9[sp]当transform-style的取值为preserver-3d时,表示这个元素为真正的3d状态<br>* 默认值为flat,表示平面[or]
10[sp](1) 通过@keyframes指定动画序列<br>* @keyframes ani {<br> from {<br> transform: rotate(0deg)<br>}<br> to {<br> transform: rotate(360deg);<br>}<br>}<br>* from to也可以修改百分比,可以设置多个状态<br>*(2) 通过animation将动画应用于相应的元素<br>[1] animation-name: 动画名称,由@keyframes定义<br>[2] animation-duration: 动画的持续时间<br>[3] animation-timing-function: 动画的过渡类型<br>* ease: 变速/linear: 匀速/steps: 分步动画<br>[4] animation-delay: 动画的延迟时间<br>[5] animation-iteration-count: 动画的循环次数<br>* infinite: 无穷次<br>[6] animation-direction: 设置动画在循环中是否反向运动<br>* normal: 从from到to/reverse: 从to到from/alternate: 交替执行<br>[7] animation-fill-mode: 设置动画时间之外的状态<br>* forwards：停留在结束状态<br>[8] animation-play-state: 设置动画的状态<br>* paused: 暂停动画[or]
11[sp]百分比布局<br>(1) 宽度自适应,高度写死(320),并不是百分百还原设计图<br>(2) 图标都是固定死大小的,包括字体等也是固定死的.并不是所有的东西都是自适应的<br>(3) 一些大的图片,设置宽度为百分比自适应即可,随着屏幕大小进行变化<br>(4) 设计图一般是2倍图或者3倍图,是为了在手机端显示更清晰[or]
12[sp](1) 左侧固定,右侧自适应<br>(2) 右侧固定,左侧自适应<br>(3) 两侧固定,中间自适应(圣杯布局,双飞翼布局)<br>(4) 等分布局[or]
13[sp](1) 当给一个盒子设置了display: flex之后,这个盒子就是一个弹性容器,而弹性容器是弹性布局的前提,没有弹性容器就不存在弹性布局<br>(2) 当给一个盒子设置了display: flex之后,这个盒子就有了主轴(默认水平)和侧轴(和主轴保持垂直)的概念<br>(3) 一旦设置了弹性容器,里面的所有的子元素会自动成为项目,而项目默认会以主轴排列<br>* 主轴: Flex容器的主轴主要用来配置Flex项目,默认是水平方向<br>* 侧轴: 与主轴垂直的轴称作侧轴,默认是垂直方向的<br>* 方向: 默认主轴从左向右,默认侧轴从上到下[or]
14[sp]flex-diretion主要是用来调整主轴的方向的,默认是水平方向(1) row:主轴方向为水平向右<br>(2) column: 主轴方向为竖直向下<br>(3) row-reverse: 主轴方向为水平向左<br>(4) column-reverse: 主轴方向是竖直向上[or]
15[sp]justify-content主要用来设置主轴方向的对齐方式(1) flex-start: 弹性盒子元素将向起始位置对齐<br>(2) flex-end: 弹性盒子元素将向结束位置对齐<br>(3) center: 弹性盒子元素将向行中间位置对齐<br>(4) space-around: 弹性盒子元素会平均地分布在行里<br>(5) space-between: 第一个贴左边,最后一个贴右边,其他盒子均分,保证每个盒子之间的空隙是相等的[or]
16[sp]align-items用于调整侧轴的对齐方式<br>(1) flex-start: 元素在侧轴的起始位置对齐<br>(2) flex-end: 元素在侧轴的结束位置对齐<br>(3) center: 元素在侧轴上居中对齐<br>(4) stretch: 元素的高度会被拉伸到最大(不能给死高度)[or]
17[sp]flex-wrap属性控制flex容器是单行或者多行,默认不换行<br>(1) nowrap: 不换行（默认），会压缩子盒子的宽度<br>(2) wrap: 当宽度不够的时候,会换行[or]
18[sp]align-content用来设置多行的flex容器的排列方式<br>(1) flex-start: 各行向侧轴的起始位置堆叠<br>(2) flex-end: 各行向弹性盒容器的结束位置堆叠<br>(3) center: 各行向弹性盒容器的中间位置堆叠<br>(4) space-around: 各行在侧轴中平均分布<br>(5) space-between: 第一行贴上边,最后一个行贴下边,其他行在弹性盒容器中平均分布<br>(6) stretch: 拉伸,不设置高度的情况下[or]
19[sp]flex属性用来设置子盒子如何分配主轴空间[or]
20[sp]order属性定义项目的排列顺序.数值越小,排列越靠前,默认为0[or]
21[sp]align-self也是用于设置在侧轴的位置,但是align-self给子元素设置,优先级比align-items的优先级高[or]
22[sp]一个网站能够兼容多个终端(手机/平板/pc电脑),而不是为每个终端做一个特定的版本[or]
23[sp](1) 大屏设备: >1200px<br>(2) 中屏设备: 992px~1200px<br>(3) 小屏设备: 768px~992px<br>(4) 超小屏设备: < 768px<br>[or]
24[sp]@media screen and (min-width: 768px) {...}<br>* 覆盖式的写法: 先写最大范围的,然后用小范围的覆盖大范围的[or]