1[sp](1) 双击解压安装(非中文路径)<br>(2) 运行模式选择"非服务模式"<br>(3) 运行状态为绿灯即为正常运行<br>(4) 如果出现端口冲突,右键任务栏的phpstudy->phpStudy设置->修改端口,点击应用->勾选"允许目录列表"->访问localhost:端口号[or]
2[sp](1) windows: ipconfig<br>(2) linux: ifconfig[or]
3[sp](1) 简单的说就是记录IP地址和域名之间对应关系的服务<br>(2) Hosts是一个没有扩展名的系统文件,可以用记事本等工具打开,其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联"数据库",当用户在浏览器中输入一个需要登录的网址时,系统会首先自动从Hosts文件中寻找对应的IP地址,一旦找到,系统会立即打开对应网页,如果没有找到,则系统会再将网址提交DNS域名解析服务器进行IP地址的解析.<br>(3) 修改C:\Windows\System32\drivers\etc\hosts文件[or]
4[sp]协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则<br>HTTP协议,即超文本传输协议(Hypertext transfer protocol).是一种详细规定了浏览器和服务器之间互相通信的规则，HTTP协议分为请求和响应两个部分组成[or]
6[sp]// 1.创建一个XMLHttpRequest对象<br>var xhr = new XMLHttpRequest()<br>// 2.设置请求行<br>//第一个参数:请求方式-get/post<br>第二个参数:请求的地址,需要在url后面拼上参数列表<br>xhr.open("get","08.php?name=ye2k")<br>// 3.设置请求头<br>浏览器会给我们默认添加基本的请求头,get请求时无需设置<br>// 4.设置请求体<br>// get请求的请求体为空,因为参数列表拼接到了url后面了[or]
7[sp]var xhr = new XMLHttpRequest<br>// 1.设置请求行,post请求的参数列表在请求体中<br>xhr.open("post","09.php)<br>// 2.设置请求头,post请求必须设置content-type,不然后端无法获取到数据<br>xhr.setRequestHeader("content","application/x-www-form-urlencoded")<br>// 3.设置请求体<br>xhr.send("name=ye2k&age=25")[or]
8[sp]// 给xhr注册一个onreadysatechange事件,当xhr的状态发生改变时,会触发这个事件<br>xhr.onreadystatechange = function(){<br>if(xhr.readyState == 4){<br>// 1.获取状态行<br>xhr.status<br>//获取响应头<br>xhr.getAllResponseHeaders()<br>xhr.getResponseHeader("content-type")<br>// 3.获取响应体<br>xhr.responseText}}[or]
9[sp]readyState记录了XMLHttpRequest对象的当前状态<br>0: 请求未初始化<br>1: 请求已经建立,但是还没有开始发送<br>2: 请求已经发送,正在处理中<br>3: 请求在处理中,中长响应中已有部分数据可用了,但是服务器还没有完成响应的生成<br>4: 响应已完成,可以获取并使用服务器的响应了[or]
10[sp](1) 是什么:[1] 可扩展标记语言(EXtensible Markup Language)<br>[2] 是一种标记语言,很类似 HTML<br>[3] 设计宗旨是传输数据,而非显示数据<br>[4] 标签没有被预定义,需要自行定义标签<br>(2) 语法规范:[1] 必须有一个根元素(有且仅有一个)<br>[2] 标签不可有空格;不可以数字或.开头;大小写敏感<br>[3] 不可交叉嵌套,都是双标签,如果是单标签,必须闭合<br>[4] 属性双引号(浏览器自动修正成双引号了)<br>[5] 注释和HTML一样[or]
11[sp](1) 定义: JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式.它基于ECMAScript规范的一个子集,采用完全独立于编程语言的文本格式来存储和表示数据<br>(2) 特点:<br>[1] 数据在名称/值对中;<br>[2] 数据由逗号分隔(最后一个健/值对不能带逗号)<br>[3] 花括号保存对象,方括号保存数组<br>[4] 键使用双引号[or]
12[sp](1) js对象->json字符串:<br>// obj是一个js对象<br>var obj = {a: 'Hello',b: 'World'}<br>// result就变成了一个json字符串了<br>var result = JSON.stringify(obj)<br>(2) // json是一个字符串<br>var json = '{"a": "Hello", "b": "World"}'<br>// obj就变成了一个js对象<br>var obj = JSON.parse(json)[or]
13[sp]form标签是表单标签,常用的属性有:<br>action: 表单提交的地址;<br>method: 请求方式(常用get和post两种),默认是get[or]
14[sp](1) get请求会把请求的数据拼接到url中<br>(2) post请求不会把请求的数据拼接到url中,会放在请求体中<br>(3) 安全性: post请求会比get请求稍微安全一点<br>(4) get请求提交的数据不能超过4k;post提交的数据没有大小限制[or]
15[sp](1) 请求行<br>[1] get请求的请求行中有数据,数据拼接到到url的后面<br>[2] post请求的url中没有数据<br>(2) 请求头: post请求相比get请求多了两个请求头<br>[1] content-length: 请求数据的长度<br>[2] content-type: 请求的内容的类型<br>(3) 请求体:[1] get请求没有请求体<br>[2] post请求有请求体[or]
16[sp]异步的代码会交给浏览器监控,可以执行时放入待执行队列,在js主线程完成时执行队列中的代码[or]
17[sp](1) url->后台地址<br>(2) type->请求方式->get/post<br>(3) dataType->服务器返回的数据格式->json/xml/text;如果不指定,会自动根据content-type进行判定<br>(4) data->发送的请求数据->对象/字符串<br>(5) beforeSend->调用前的回调函数,在beforeSend中return false,会阻止ajax的发送<br>(6) succese->成功的回调函数->function(data){}<br>(7) error->失败的回调函数->function(error){}<br>(8) complete->完成后的回调函数->function(){}[or]
18[sp](1) $.post(url,[data],[callback],[dataType])<br>(2) $.get(url,[data],[callback],[dataType])[or]
19[sp](1) 引入模板引擎的js文件"<script src="template-web.js"></script>"<br>(2) 准备模板<br><script type="text/html" id="myTmp"><br><p>姓名:yk</p><br><p>年龄:25</p><br><p>宠物:小黑</p><br></script><br>(3) 准备数据<br>var json = {<br>userName:"yk",<br>age:25,<br>pet:"小黑"<br>}<br>(4) 将模板与数据进行绑定<br>第一个参数:模板的id<br>//第二个参数:数据<br>//返回值:根据模板生成的字符串<br>var html = template("myTmp",json);<br>console.log(html);<br>(5) 修改模板<br><script type="text/html" id="myTmp><br><p>姓名: {{userName}}</p><br><p>年龄: {{age}}</p><br><p>宠物: {{pet}}</p><br>(6) 将数据显示到页面<br>var div = document.querySelector("div")<br>div.innerHTML = html;</script>[or]
20[sp](1) if语法:<br>{{if gender="男"}}<br>  <div class="man"><br>{{else}}<br>  <div class="woman"><br>{{/if}}<br>(2)each语法:{{each data(被遍历的对象/数组) value index}}<br><li><br> <a href="{{v.url}}"><br>  <img src="{{v.src}}" alt=""><br><p>{{v.content}}</p><br></a><br></li><br>{{each}}[or]
21[sp](1) H5中定义了data-xxx的规范来存放自定义属性,并且给所有的DOM对象新增了一个dataset属性<br>(2) 使用Element.dataset.xxx即可获取自定义属性<br>* 在jquery中,针对data-xxx这种规范的属性,提供了data()方法,参数直接写xxx即可获取到data-xxx属性[or]
22[sp]这个方法会自动把所有需要发送的input中的参数内容序列化为一个字符串<br>(1) 要求form表单中的子元素必须设置name属性<br>(2) 不包括属性为按钮的input[or]
23[sp]指的是两个网页要有三个相同:<br>(1) 协议相同: http https<br>(2) 域名相同: www.baidu.com kaizai.xyz<br>(3) 端口相同: 80 8080[or]
24[sp]为了保护用户信息的安全,防止恶意的网站窃取数据[or]
25[sp](1) Cookie/LocalStorage/IndexDB<br> (2) DOM<br>(3) AJAX请求[or]
26[sp]借助了script标签不受同源策略的限制<br>服务端: 返回一个函数的调用,将数据当做调用函数的实参<br>浏览器端: 需要程序声明一个函数,通过形参就可以获取到服务端返回的对应值[or]
27[sp]在$.ajax中将dataType设置为jsonp即可[or]
28[sp]跨域资源共享<br>前提:<br>* 浏览器必须支持这个功能<br>* 服务器必须允许这种跨域[or]
29[sp](1) 浏览器会向发送一条请求,服务器接受到请求之后,会返回请求头信息,浏览器查看返回的响应头信息中是否设置了header('Access-Control-Allow-Origin:请求源域名或者*')<br>(2) 如果没有设置,说明服务器不允许使用cors跨域,那么浏览器会把获取到的数据拦截<br>(3) 如果返回的响应头中设置了header('Access-Control-Allow-Origin:请求源域名或者*');,浏览器会跟请求头中的Origin: 进行对比,如果满足要求,就把数据发送给用户<br>(4) 跨域行为是浏览器行为,是浏览器阻止了ajax行为.服务器与服务器之间是不存在跨域的问题的[or]
30[sp](1) <input type="file" multiple><br>(2) var fd = new FormData()<br> fd.append("pic", this.files[0])<br>(3)ajax中:<br> processData: false<br>contentType: false<br> data: fd[or]