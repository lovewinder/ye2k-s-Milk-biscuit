1[sp](1) &&会返回第一个遇到的假值.如果全为真值,则返回最后一个值(常用于兼容判断)<br>(2) ||会返回第一个遇到的真值.如果全为假值,会返回最后一个值(常用于添加默认值)[or]
2[sp](1) new Object()创建(只能创建一个空对象,每个属性都需要手动添加)<br>(2) 对象字面量创建(每次只能创建一个对象)<br>(3) 工厂函数(所有创建出来的对象都是Object类型的)<br>(4)自定义构造函数(每个对象都要一个新的内存存放同一个函数,浪费内存)->可以使用命名函数的方式来解决,但是这样又会暴露很多函数,还容易遭成全局变量污染[or]
3[sp](1) 创建一个新对象<br>(2) 将构造函数的作用域赋给新对象(this指向这个新对象)<br>(3) 执行构造函数中的代码<br>(4) 返回新对象[or]
4[sp](1) js规定,每一个函数都有一个prototype属性<br>(2) prototype属性指向一个对象,我们把这个对象成为原型对象<br>(3) 这个对象的所有属性和方法,都会被构造函数的实例继承<br>Person.prototype.type = "human"<br>Person.prototype.sayName = function(){<br>console.log(this.name)<br>}<br>此时所有的Person实例都自带type属性和sayName()方法,并且是同一个内存地址[or]
5[sp](1) 任何一个对象都会有__proto__属性,这个属性指向了构造函数的prototype,即原型对象<br>(2) 构造函数.prototype === 实例.__proto__<br>(3) __proto__是浏览器的一个隐藏(私有)属性,IE浏览器不支持,不要通过它来修改原型里的内容,如果要修改原型中的内容,使用构造函数.prototype来修改[or]
6[sp](1) 任何一个对象都有原型对象,原型对象本身又是一个对象,所以原型对象也有自己的原型对象,这个链式结构称为原型链<br>(2) 实例p -> Person.prototype -> Object.prototype -> null<br>(3) Object.prototype是原型链的尽头,Object.prototype的原型是null<br>*所有函数(Function和Object)都是Function创建的,函数.__proto__ === Function.prototype<br>*所有的原型对象(除了Object.prototype)都是Object创建,原型对象.__proto__ === Object.prototype[or]
7[sp](1) 获取属性:<br>[1] 会先在自身上查找<br>[2] 找不到之后根据__proto__对应的原型去找<br>[3] 一直找到Object.prototype如果仍然没有,那就是找不到了<br>(2) 设置属性:<br>修改一个对象的属性,如果自身没有这个属性,会添加这个属性,并不会修改原型中的属性[or]
8[sp]每一个原型对象自带一个属性constructor指向实例的构造函数[or]
9[sp]*根据函数内部this的指向不同,将函数的调用模式分成4种<br>(1) 函数调用模式: 如果一个函数不是对象的属性时,就是被当做一个函数来进行调用,此时this指向了window<br>(2) 方法调用模式: 当一个函数被保存为对象的一个属性时,是被当做一个方法.当一个方法被调用时,this被绑定到当前对象<br>(3) 如果函数式通过new关键字进行调用的,此时this被绑定到创建出来的新对象上<br>(4) 上下文调用模式: 也被称为方法借用模式<br>[1] call方法可以调用一个函数,并且可以指定这个函数的this指向<br>写法:fn.call(thisArg(指定函数的this,如果不传,则this指向window),arg1,arg2,arg3(其余参数和源函数的参数列表一样));<br>[2] apply方法和call方法用法类似,call方法接收的是一个包含多个参数的数组,当参数比较多时/存放在数组中时使用apply更方便<br>[3] bind方法创建一个新的函数时使用,可以指定这个函数this的指向,无论使用何种调用模式,this都不会改变,不会执行函数;<br>var newFn = fn.bind(window)<br>* [or]
10[sp](1) 递归函数要求函数内部直接或间接的调用自己<br>(2) 递归函数要有结束条件[or]
11[sp](1) js的函数中(嵌套)定义另一个函数时,如果内部的函数引用了外部的函数的变量,则产生闭包 -> 当内部函数访问了外部函数的变量的时候,就会形成闭包<br>(2) 闭包可以保护私有变量不被修改<br>(3) 闭包占用的内存是不会被释放的,如果滥用闭包,会造成内存泄漏[or]
12[sp](1) 引用计数法: 如果没有引用指向某个对象(或者是函数作用域),name这个对象活着函数作用域就会被垃圾回收机制回收(在循环引用时会导致内存泄漏的问题,已被废弃)<br>(2) 标记清除法: 这个算法假定设置一个叫做根(root)的对象(在js里,根是全局对象Window).垃圾回收器定期的将从根开始,找所有从根开始引用的对象,然后找这些对象引用的对象,一路下来没有被这条线上的对象引用的对象都将会被回收(2012年器,所有现代浏览器都使用了标记-清除垃圾回收算法)[or]
13[sp](1) 命名函数: function fn(){...}<br>可以先调用,再声明(函数声明会预解析)<br>(2) 匿名函数: var fn1 = function(){...} fn1()<br>必须先声明,后调用<br>(3) 构造函数的方式(函数实质上也是对象): new Function(arg1,arg2,...,(<-函数的形参)body(<-函数体))[or]
14[sp](1) 作用域是指变量起作用的区域,在js中,只有函数会形成作用域,js中只有全局作用域,局部作用域<br>(2) js中函数会形成作用域,如果函数内部还有函数,内部的函数也会形成作用域,多个作用域的嵌套就形成作用域链(内层函数能访问外层函数)[or]
15[sp](1) 浅克隆: 只会复制对象的一层属性,即便这个属性的值是一个对象也只会复制地址,并不能保证两个对象完全独立<br>(2) 会复制对象的每一层属性,如果这个属性的值是对象,会继续克隆这个对象,保证两个对象完全独立[or]
16[sp](1) 正则表达式的创建:<br>[1] 字面量: var reg = /zs/<br>[2] 构造函数: var = new RegExp(/b/)<br>(2) 正则表达式的使用: reg.test()<br>[or]
17[sp](1) \d: 匹配数字<br>(2) \D: 匹配非数字<br>(3) \w: 匹配大小写字母/数字/下划线->即单词字符<br>(4) \W: 匹配非单词<br>(5)\s: 匹配不可见字符->空格/换行<br>(6) \S: 匹配可见字符<br>(7) \.:匹配.<br>(8).: 匹配任意字符[or]
18[sp](1) |: 或者(优先级最低)<br>(2) (): 分组(优先级最高)[or]
19[sp](1) [...]: 代表[]中任意一个字符<br>(2) [a-z]: 匹配a到z中的任意一个字符<br>(3) [0-9]: 匹配0-9中的任意一个字符<br>(4) [^...]: 表示不能是[]中的任意一个字符<br>*[a-zA-Z]表示任意一个字母(大小写都可以)[or]
20[sp](1) *: 可以出现0次或多次<br>(2) +: 可以出现1次或者多次<br>(3) ?: 可以出现0次或者1次<br>(4) {m}: 精确控制要出现m次<br>(5) {m,n}: 出现次数大于等于m次,小于等于n次<br>(6) {m,}: 出现次数大于等于m次[or]
21[sp](1) ^: 表示开始<br>(2) $: 表示结束[or]
22[sp](1) 原型链继承: 实例直接继承了原型,只需要给原型对象添加方法,所有的实例都可以直接访问(主要是用于继承方法)<br>[1] 如果想要给实例添加一些方法,可以直接给原型添加<br>[2] 如果需要添加的方法特别多,可以考虑替换原型(记得给新的原型添加constructor指向实例的构造方法)<br>(2) 借用构造函数继承(主要是用于继承属性):<br>function Person(name,age){<br> this.name = name<br> this.age = age<br>}<br>function Chinese(name,age){<br> Person.call(this,name,age)<br> this.skin = "yellow"<br>}<br>(3) 组合继承: 先在子类的构造函数中通过借用构造函数继承的方式继承父类的属性,再将子类的构造函数的原型指向父类的实例(继承父类原型中的方法),再将子类构造函数的原型的constructor指回自己的构造函数(这样就能获取到自己构造函数的方法和属性了)