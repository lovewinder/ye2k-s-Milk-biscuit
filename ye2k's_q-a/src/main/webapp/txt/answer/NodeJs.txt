1[sp](1) forEach要求传入一个自定义函数作为参数<br>(2) forEach会遍历数组,它会在遍历到数组中的每一项内容时,自动调用传入的自定义函数<br>(3) 可以给自定义函数添加参数(element,index,array)<br>[1] element表示元素<br>[2] index表示索引<br>[3] array表示遍历的数组本身[or]
2[sp](1) 不会造成全局变量污染<br>(2) 可以简化代码(配合箭头函数使用)[or]
3[sp](1) map循环数组,会将自定义函数的返回值保存到一个新数组中,最后将这个新数组返回<br>(2) var newArr = arr.map(function(ele) { return ... }[or]
4[sp](1) 遍历数组,将满足条件的数组中的内容,放到一个新数组中,最终返回这个新数组<br>(2) var newArr = arr.filter(function(ele) { if(ele >10) { return true } else { return false } }[or]
5[sp](1) 只要数组中有一个满足条件,就会返回true,否则返回false<br>(2) arr.some(function(ele) { if(ele % 2 ===1){ return true } else{ return false } }[or]
6[sp](1) 只有数组中每项内容都满足条件才会返回true,否则就返回false<br>(2) arr.every(function(ele) { ... }[or]
7[sp](1) let不会预解析,(不会变量提升)<br>(2) let不能重复声明变量<br>(3) let有一个块级作用域,在{}内声明的变量只能在{}内使用[or]
8[sp](1) 表示常量,值不能被修改<br>(2) 要求声明和赋值同时进行<br>(3) 对象是一个复杂类型,如果用const来定义对象,是可以修改对象中的属性的,但是不能让这个对象指向新的内存地址<br>(4) 拥有let的所有特性[or]
9[sp](1) 解构对象,将对象中的属性拿出来赋值给一个变量<br>(2) const { 对象的属性名 : 要赋值的变量名, 对象的属性名 : 要赋值的变量名 ... } = 要解构的对象<br>(3) 当要解构的对象的属性名和要赋值的变量名相同时, ": 变量名"可以省略<br>(4) 变量名可以自定义, const { verylongname: name } = zheshiyigeduixiang<br>(5) 解构赋值可以解构对象中的方法, const { log } = console<br>log(1)<br>(6) 可以设置默认值, const { name, desc = "默认描述" } = obj <br>如果desc没有值,则使用默认值<br>(7) 解构赋值可以解构函数中的参数(参数必须是对象)[or]
10[sp]const arr = ["red", "green", "yellow"]<br>(1) const [color1, color2, color3] = arr<br>全元素获取<br>(2) const [,color2, color3] = arr<br>前置元素省略获取<br>(3) const [,color] = arr<br>前置后置省略[or]
11[sp]`...`<br>(1) 支持换行<br>(2) 可以变量解析<br>`<p>姓名:${user.name + "说: 你好"}</p>`[or]
12[sp]判断abc是不是字符串的开头<br>const str = "abcde"<br>str.startsWith("abc")[or]
13[sp]判断cde是不是字符串的结尾<br>const str = "abcde"<br>str.endsWith("cde")[or]
14[sp]判断bcd是不是在字符串中<br>const str = "abcde"<br>str.includes("bcd")[or]
15[sp]循环遍历数组,会将第一个满足条件(自定义函数返回true)的数组项返回[or]
16[sp]循环遍历数组,会将第一个满足条件(自定义函数返回true)的数组下标返回[or]
17[sp](1) const fn = (参数列表) => { ... }<br>(2) 特殊写法<br>[1] 当参数列表的数量只有一个时,()可以省略<br>[2] 当函数体内的代码只有一行时,{}可以省略<br>[3] 在[2]的前提下,如果只有一行带return的代码,return也可以省略[or]
18[sp]箭头函数是没有this的,如果非要在箭头函数中要找this,它只会往外面找[or]
19[sp](1) ES6中,可以直接给函数的参数指定默认值<br>const add = function(a = 0, b = 0){ console.log(a + b) }<br>(2) 可以获取除某些参数之外的剩余参数 ...rest<br>const fn = function(a, b, ...rest) { ... }<br>注: 箭头函数没有arguments属性[or]
20[sp](1) 当属性名和变量名相同时,": 变量名"可以省略<br>const obj = { name: name, age: age }<br>const obj = { name, age }<br>(2) 对象方法的简写: function可以直接省略<br>const obj = { name: "张三", fn: function() { console.log(this.name) }}<br> const obj = { nam: "张三", fn(){ console.log(this.name) }}[or]
21[sp]语法: ...<br>(1) 拼接数组: <br>const arr1 = [1, 2, 3, 4]<br>const arr2 = [5, 6, 7, 8]<br>const arr3 = [...arr1, 10, ...arr2]<br>(2) 求数组中的最大值<br>const arr = [1, 10, 100, 25]<br>const max = Math.max(...arr)<br>(3) 展开对象<br>const obj1 = { name: "张三", age: 60 }<br>const obj2 = { money: 100000000 }<br>const obj3 = { ...obj1, ...obj2 gf: "qbhn"}[or]
22[sp]Set是ES6中新提供的一种复杂类型,会保证其中保存的数据不重复<br>const arr = [1, 2, 3, 4, 1, 2, 3, 4]<br>console.log([...new Set(arr)])[or]