1[sp](1) forEach要求传入一个自定义函数作为参数<br>(2) forEach会遍历数组,它会在遍历到数组中的每一项内容时,自动调用传入的自定义函数<br>(3) 可以给自定义函数添加参数(element,index,array)<br>[1] element表示元素<br>[2] index表示索引<br>[3] array表示遍历的数组本身[or]
2[sp](1) 不会造成全局变量污染<br>(2) 可以简化代码(配合箭头函数使用)[or]
3[sp](1) map循环数组,会将自定义函数的返回值保存到一个新数组中,最后将这个新数组返回<br>(2) var newArr = arr.map(function(ele) { return ... }[or]
4[sp](1) 遍历数组,将满足条件的数组中的内容,放到一个新数组中,最终返回这个新数组<br>(2) var newArr = arr.filter(function(ele) { if(ele >10) { return true } else { return false } }[or]
5[sp](1) 只要数组中有一个满足条件,就会返回true,否则返回false<br>(2) arr.some(function(ele) { if(ele % 2 ===1){ return true } else{ return false } }[or]
6[sp](1) 只有数组中每项内容都满足条件才会返回true,否则就返回false<br>(2) arr.every(function(ele) { ... }[or]
7[sp](1) let不会预解析,(不会变量提升)<br>(2) let不能重复声明变量<br>(3) let有一个块级作用域,在{}内声明的变量只能在{}内使用[or]
8[sp](1) 表示常量,值不能被修改<br>(2) 要求声明和赋值同时进行<br>(3) 对象是一个复杂类型,如果用const来定义对象,是可以修改对象中的属性的,但是不能让这个对象指向新的内存地址<br>(4) 拥有let的所有特性[or]
9[sp](1) 解构对象,将对象中的属性拿出来赋值给一个变量<br>(2) const { 对象的属性名 : 要赋值的变量名, 对象的属性名 : 要赋值的变量名 ... } = 要解构的对象<br>(3) 当要解构的对象的属性名和要赋值的变量名相同时, ": 变量名"可以省略<br>(4) 变量名可以自定义, const { verylongname: name } = zheshiyigeduixiang<br>(5) 解构赋值可以解构对象中的方法, const { log } = console<br>log(1)<br>(6) 可以设置默认值, const { name, desc = "默认描述" } = obj <br>如果desc没有值,则使用默认值<br>(7) 解构赋值可以解构函数中的参数(参数必须是对象)[or]
10[sp]const arr = ["red", "green", "yellow"]<br>(1) const [color1, color2, color3] = arr<br>全元素获取<br>(2) const [,color2, color3] = arr<br>前置元素省略获取<br>(3) const [,color] = arr<br>前置后置省略[or]
11[sp]`...`<br>(1) 支持换行<br>(2) 可以变量解析<br>`<p>姓名:${user.name + "说: 你好"}</p>`[or]
12[sp]判断abc是不是字符串的开头<br>const str = "abcde"<br>str.startsWith("abc")[or]
13[sp]判断cde是不是字符串的结尾<br>const str = "abcde"<br>str.endsWith("cde")[or]
14[sp]判断bcd是不是在字符串中<br>const str = "abcde"<br>str.includes("bcd")[or]
15[sp]循环遍历数组,会将第一个满足条件(自定义函数返回true)的数组项返回[or]
16[sp]循环遍历数组,会将第一个满足条件(自定义函数返回true)的数组下标返回[or]
17[sp](1) const fn = (参数列表) => { ... }<br>(2) 特殊写法<br>[1] 当参数列表的数量只有一个时,()可以省略<br>[2] 当函数体内的代码只有一行时,{}可以省略<br>[3] 在[2]的前提下,如果只有一行带return的代码,return也可以省略[or]
18[sp]箭头函数是没有this的,如果非要在箭头函数中要找this,它只会往外面找[or]
19[sp](1) ES6中,可以直接给函数的参数指定默认值<br>const add = function(a = 0, b = 0){ console.log(a + b) }<br>(2) 可以获取除某些参数之外的剩余参数 ...rest<br>const fn = function(a, b, ...rest) { ... }<br>注: 箭头函数没有arguments属性[or]
20[sp](1) 当属性名和变量名相同时,": 变量名"可以省略<br>const obj = { name: name, age: age }<br>const obj = { name, age }<br>(2) 对象方法的简写: function可以直接省略<br>const obj = { name: "张三", fn: function() { console.log(this.name) }}<br> const obj = { nam: "张三", fn(){ console.log(this.name) }}[or]
21[sp]语法: ...<br>(1) 拼接数组: <br>const arr1 = [1, 2, 3, 4]<br>const arr2 = [5, 6, 7, 8]<br>const arr3 = [...arr1, 10, ...arr2]<br>(2) 求数组中的最大值<br>const arr = [1, 10, 100, 25]<br>const max = Math.max(...arr)<br>(3) 展开对象<br>const obj1 = { name: "张三", age: 60 }<br>const obj2 = { money: 100000000 }<br>const obj3 = { ...obj1, ...obj2 gf: "qbhn"}[or]
22[sp]Set是ES6中新提供的一种复杂类型,会保证其中保存的数据不重复<br>const arr = [1, 2, 3, 4, 1, 2, 3, 4]<br>console.log([...new Set(arr)])[or]
23[sp](1) 导入模块<br>const fs = require("fs")<br>(2) 读取文件 语法: fs.readFile(文件路径,文件读取后的回调函数)<br>[1] err: 错误,如果文件读取错误,err表示具体错误信息,如果读取成功,err就是空<br>[2] data 读取到的文件的内容,在默认情况下,data就是Buffer类型,可以调用 .toString()转换成字符串<br>[3] 如果文件读取失败,data也是空<br>(3) 如果要读取一个文本文件<br>语法: fs.readFile(文件路径,字符类型(utf8),回调函数){ ... }(4) 同步读取文件<br>const data = fs.readFileSync(文件路径,编码格式)[or]
24[sp](1) 导入fs<br>(2) 语法: writeFile(文件路径,写入的内容,回调函数)<br>[1] 如果有这个文件,覆盖写入的内容<br>[2] 如果没有这个文件,新建一个文件,并写入内容<br>[3] 如果没有目录,报错<br>(3) appendFile(文件路径,追加的内容,回调函数)[or]
25[sp](1) 相对路径是相对于node的执行目录<br>(2) 绝对路径(推荐使用)[or]
26[sp](1) __dirname: 获取当前文件的所在目录的绝对路径<br>(2) __filename: 获取当前文件的绝对路径[or]
27[sp]在node中,有一个global的全局变量,它里面的属性和方法,在js的任意位置都可以使用,相当于web端的window[or]
28[sp]在node中,path模块是专门用来处理路径的相关工作的<br>(2) path.join专门用来拼接路径<br>[1] const path = require("path")<br>[2]path.join("a", "b", "c", "d.html")<br>[3] 会根据不同的操作系统自动添加对应的分隔符,并且会自动判断是否重复添加了分隔符[or]
29[sp](1) path.dirname() 返回目录<br>(2) path.basename() 返回文件名<br>(3) path.extname() 返回扩展名(.xxx)[or]
30[sp](1) 导入http模块<br>const http = require("http")<br>(2) 创建服务器<br>http.createServer()<br>(3) 启动服务器并监听端口<br>server.listen(port,callback)<br>(4) 监听并处理请求<br>server.on("request", callback)<br>在这个回调函数中有两个参数<br>[1]req: 请求<br>[2]res: 响应[or]
31[sp](1) 请求行<br>[1] 请求地址: req: url<br>[2] 请求方式: req: method<br>(2) 请求头: req: headers<br>(3) 请求体[or]
32[sp](1) 响应码(状态码)<br>res.statusCode = 200<br>(2) 响应头<br>res.setHeader("content-type","text/html;charset=utf-8")<br>(3) 响应体<br>res.writer: 在一次请求中,可以多次调用,每调用一次,将部分数据放到响应体中<br>res.end: 在一次请求中,只可以调用一次,并结束响应体[or]
33[sp](1) 安装: npm install mime<br>(2) 导入模块: const mime = require("mime")<br>(3) 获取mime类型: const mimeType = mime.getType(req.url)<br>(4) 设置请求头: res.setHeader("content-type",mimeType)[or]
34[sp](1) 初始化: npm init<br>[1] 创建了一个package.json的文件<br> npm init -y: 跳过初始化询问(2) 安装: npm install 包名<br>[1] node_mudules下新增对应包<br>[2] package.json中的dependencies显示加入项目的包<br>[3] npm install会根据package.json记录的依赖信息自动下载依赖的包<br>[4] npm install 包名@版本号: 安装指定的版本<br>[5] 简写: npm i<br>[6] 一次安装多个包: npm install 包1 包2<br>(3) npm uninstall 包名<br>[1] 安装不同版本的包时最好先把旧的包卸载<br>[2] 简写: npm un[or]
35[sp](1) name: 包名<br>(2) version: 版本号<br>(3) description: 具体没描述<br>(4) main: 入口文件<br>(5) scripts: 可用的脚本<br>(6) keywords: 关键字(方便搜索)<br>(7) author: 作者的名字<br>(8) license: 协议<br>(9) dependencies: 项目的依赖[or]
36[sp](1) 本地安装: 每个项目要的第三方包是不一样的,所以一般每个项目依赖都是安装在当前项目文件夹中<br>(2) 全局安装: npm, node这些命令行工具一般都是全局安装的,只要安装一次,在任何项目下都能使用<br>[1] npm install 包名 -g[or]
37[sp](1) npm i nrm -g<br>(2) nrm ls: 列出所有可用的仓库地址<br>(3) nrm use taobao[or]
38[sp](1) nodemon可以执行js文件<br>(2) 它会监听当前目录,当发现目录下的代码被修改,它会重新执行js文件<br>[or]